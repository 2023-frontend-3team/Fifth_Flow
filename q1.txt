Q1. 리액트를 사용하는 이유를 설명해보세요 (2가지 이상)
    --페어1--
    1. 가볍고 유연한 라이브러리로 필요한 부분에만 적용이 가능하다
    2. 자바스크립트 기반의 문법을 사용하기 때문에 자바스크립트에 익숙하다면 쉽게 사용할 수 있어서
    3. 가상돔을 이용하여 리랜더를 최소화    
    
    --페어2--
    1. 재사용 가능한 함수들을 만들어서 지속적인 사용 가능
		- nav, header, footer, => 하나의 함수를 선언 해놓고 지속적으로 호출 가능
	2.  컴포넌트로 나뉘어진 홈페이지의 코드는 가독성이 좋고, JS의 DOM 보다 쉽게 구현 가능



Q2. 리액트가 가상 돔을 사용하는 이유는 무엇일까요?
    --페어1--
    - 실제 DOM을 사용하는데 시간을 줄여주기 때문이다
    - 동적인 페이지를 만들기 위해서
    - 실제돔과 비교하여 수정된 부분만 리랜더-> 로딩시간 최소화
    
    --페어2--
    컴포넌트로 나뉘어져 있기떄문에, 변경사항을 적용할 때 빠르게 로딩될 수 있다.
	수정되는 부분만을 적용하여 렌더링을 하기 위해서

Q3. 리액트가 가상 돔과 돔 트리를 비교하여 바뀐 부분이 있다면 화면을 다시 그리는 행위를 무엇이라 할까요?
    - Reconciliation
    - Rerender

Q4. (Q3)의 행위를 통해 얻을 수 있는 이점은 무엇이며 언제 실행될까요?
    --페어1--
    - 가상 돔과 실제 돔의 차이를 계산하고 변경된 부분만 업데이트를 해서 성능을 최적화 한다
    - 상태가 변경되었을때 실행된다

    --페어2--
    useState() => 개발자가 변경 사항을 보고싶을때, 실행됨
	트리 구조의 장점 => 검색이 빨라요!
	검색이 빨라요! => (Diff 알고리즘)
	렌더 트리


Q5. 리액트는 SPA입니다. 이에 따라 index.html이 하나 뿐인데요.
		어떻게 주소마다 다른 화면을 보여줄 수 있을까요? 그리고 그로 인한 장점은 무엇일까요?
        
    --페어1--
    라우팅 라이브러리를 사용하여 주소에 연결된 컴포넌트를 보여준다
    페이지를 빠르게 전환할 수 있고 서버에 요청을 보내는 횟수가 적어 서버에 부담이 감소한다
    라우팅 => 주소마다 다른화면을 보여줄수 있음 


     --페어2--
     url로 데이터를 보관하여 이전데이터, 즉 다른 화면을 불러올 수 있다.
	라우팅 => 다른 주소마다 다른 페이지를 보여줄 수 있다.
	장점 : 서버에는 하나의 페이지만 있고, 자바스크립트 함수로 불러와서 페이지를 만들잖아요 => 서버에 부담이 줄꺼같아요
	단점: 자바스크립트 코드가 상당히 길어지겠네 however 재사용성으로 극복



Q6. 훅 함수는 왜 만들게 되었을까요?
    아래의 각 훅함수의 어떠한 장점이 있는지 정의를 선언하고
		반드시 그에 대한 예시를 한가지 씩 작성해보세요.

--페어1--

(1) useState : 두 번째 반환값으로 받는 업데이트 함수를 사용하여 이전 상태를 바탕으로 새로운 상태를 업데이트할 수 있다
                const [state, setState] = useState(0)
                setState(state + 1)
                <div>{state}</div>
                state값이 1씩 커진다

(2) useRef : 변수를 저장할 수 있다 렌더링에 영향을 주지 않는다 DOM요소에 쉽게 접근이 가능하다
                const ref = useRef()
                useEffect(()=> {
                    ref.current.focus()
                },[])
                <input ref=(ref) />

(3) useEffect : 컴포넌트에서 부수 효과 처리를 효율적으로 가능하고 비동기 작업을 다룰 수 있다
            // deps 안에 특정 값을 넣게 된다면, 컴포넌트가 처음 마운트 될 때에도 호출이 되고 지정한 값이 바뀔 때에도 호출이 됩니다
            useEffect(() => {
                // console.log("user 값이 설정됨");
                // console.log(user);
                return () => {
                    // console.log("user 가 바뀌기 전..");
                    // console.log(user);
                };
            }, [user]);

(4) useCallback : 렌더링 마다 새로운 함수를 생성하는 것을 방지하여 성능 최적화를 할 수 있다
                    const [count, setCount] = useState(0);
                    const handleClick = useCallback(() => {
                        setCount(count + 1);
                    }, [count]);
                    <p>{count}</p>
                    <button>+</button>

(5) useMemo :  이전에 계산된 값을 재사용하므로, 렌더링 중에 동일한 계산을 반복하지 않고 결과를 캐시(기억)할 수 있다
                const result = useMemo(() => {
                    // 복잡한 계산 또는 가공 작업
                    return data.map(item => item * 2);
                }, [data]);
                <p>계산 결과: {result.join(', ')}</p>


--페어2--
        
지정된 컴포넌트에 변경사항이 생길때마다, 리렌더 해주는 역할을 한다.
클래스 컴포넌트를 대체하기 위해 함수형 컴포넌트로 도입됨
코드가 간결해지고 가독성이 좋아진다

const[state, setState] = useState();

const handleKeyup = (e) =>{
	setState(e.value.trim())	
}

return (
	<div>
	<input type = “text” value = {state} />
	<button onChange={handleKeyup}>희범이</button>
	</div>
);



(2) useRef 
	DOM에 있는 값을 정해주다가 다시 리렌더할떄, 기존에 있던 값이 초기화 되지 않게 해주는 함수다.

	const name = new useRef();

	

(3) useEffect 

	useEffect( () => {
		console.log(‘문이 열렸음’);		=> 컴포넌트가 실행될떄
	return ()=>{
		console.log(‘문이 닫힘’)			=> 컴포넌트가 실행이 끝났거나, 실행되지 않았을떄?
	}
})

	지정된 프로퍼티를 변경시킬떄, 컴포넌트를 변경하고자 할 때 사용된다고

    (1) useState
    (2) useRef
    (3) useEffect
    (4) useCallback
    (5) useMemo



Q7. 팀원들과 리액트로 프로젝트를 만들려고할 때 고려해야하는 사항들을 아는대로 작성해보세요 (3가지 이상)
    
    --페어1--
    - 컴포넌트 및 폴더 구조를 어떻게 나눌 것인지
    - 코드 가독성을 위해 코드 컨벤션을 확실하게 정한다


    --페어2--
    1. 반복되는 컴포넌트를 먼저 구상해야한다.
    2. url param을 통해 어떤 데이터를 받아와서 페이지에 만들 수 있는지 생각해야한다.
    3. CSS관련 통일성이 있게 팀원들과 구상해야 한다.    

Q8. 리액트에서 컴포넌트를 나누는 기준은 어떻게 되어야할까요?

    --페어1--
    - 컴포넌트의 재사용성을 기준으로 나눈다
    - 하나의 컴포넌트가 하나의 기능을 하도록 나눈다
    - 컴포넌트가 너무 커지지 않도록 작게 분리한다
    - 랜더링 최적화

    --페어2--
    1. HTML5 에서 지원하는 header, nav, section, aside, footer (세그맨틱 tag)를 사용해서 각 페이지의 각 부분에 어떤 컴포넌트가 들어가야하는지를 구상할 수 있다.
